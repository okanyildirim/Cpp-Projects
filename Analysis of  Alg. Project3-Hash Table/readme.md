# Analysis of  Alg. Project3-Hash Table
<h1>Project Description</h1>

PURPOSE:  The purpose of this project is to develop a better understanding of hash tables. This is accomplished by writing a hash table class and methods. Part A. Questions on Hash Tables (20 points) 1) Why do we use Hash Tables as a data structure in our problems? Please explain briefly. (5 points) 2) Consider a hash table consisting of M = 11 slots, and suppose nonnegative integer key values are hashed into the table using the hash function h1() : int h1 (int key) { int x = (key + 7) * (key + 7); x = x / 16; x = x + key; x = x % 11; return x; } 
Suppose that collisions are resolved by using linear probing. The integer key values listed below are to be inserted, in the order given. Show the home slot (the slot to which the key hashes, before any probing), the probe sequence (if any) for each key, and the final contents of the hash table after the following key values have been inserted in the given order: (10+5 points) 

Key Value		Home Slot		Probe Sequence
43   
23   
1   
0   
15   
31   
4   
7   
11   
3  
 

Final Hash Table: Slot 0 1 2 3 4 5 6 7 8 9 10 Contents            
 
  
Part B. Implementation and Report (80 points) 
 
<h1>1) Implementation (70 points) </h1>
Problem: In this assignment, you will create a simple spell checker. The program will read some words from a file that is given as the first argument (words.txt), and apply the appropriate method to the word. The structure of the file can be seen below: 

insert:cat delete:dog retrieve:door 

While reading the dictionary, the spelling checker might run for the lines which starts with “retrieve”. Each word (with the retrieve prefix) will be looked up in the dictionary. If it is not in the dictionary, it will be written to the standard output together with a list of suggested corrections.  

In your implementation, there will be three different operations: 

 insert (key)  Inserts key into the appropriate slot in the hash table. The location (index) in the hash table is determined by the key and the hash function. 

 remove (key) Searches the hash table for the given key and delete it from the table. In order to delete a key from a hash table slot, you should just mark the corresponding slot as deleted (Lazy deletion). Since your hash table will be string type, you can use any alphanumeric (except a…z) character to mark as “deleted” (e.g. hashTable[deleteIndex]=”*”).  Remember that, during insertion, slots marked as deleted are treated as empty. So, you have to use two different markers both for deleted and emptiness. 

 retrieve (key)  Finds the given key in the hash table and return its index. If the key is not in the first slot, you have to apply linear probing from the current slot to the next empty slot. Note that the deleted slots are NOT treated as empty in this function. If the key is not in the table, it should start for correction and finally serves possible suggestions.  Note: You may implement your spell_checker() method separately if you wish. 
 
<h1>The Hash Function: </h1>
 
Let the word to be hashed be w1w2...wn where each wi 1  i  n, is a single character. Also, let ascii(x) be the ascii value of the character x. 
 
f(w1w2...wn) = [acsii(w1)*ascii(w2)*...*ascii(wn)] mod n where, n is the table size which will be given as the second argument (Use n=337 for this project but still you have to give as command line argument).  
Since the result of the multiplication might be very large number, use long long int data type for the result. However, keep in mind that when you do this computation, you may still encounter with overflow issues. You'll have to think of a way to prevent it. Here is a small example for n=59999: Consider inserting the word "dog" into the hash table: 
ascii('d')*ascii('o')*ascii('g') mod 59999  = 100*111*103 mod 59999            
											= 1143300 mod 59999            
											= 3319 
											Use the linear probing strategy for your hash table. 
<h1>Generating Corrections </h1>

The easiest way to generate corrections in a spell checker is a trial-and-error method. If we assume that the misspelled word contains only a single error, we can try all possible corrections and look each up in the dictionary. 
Traditionally, spelling checkers have looked for four possible errors: a wrong letter ("wird"), an inserted letter ("woprd"), a deleted letter ("wrd"), or a pair of adjacent transposed letters ("wrod").  
In this assignment, you will only need to deal with the first possibility; a wrong letter. When a word isn't found in the dictionary, you will need to look up all variants that can be generated by changing one letter. For example, given "wird," you should look up "aird", "bird", "cird", etc. through "zird", then "ward", "wbrd", "wcrd" through "wzrd", and so forth. Whenever you find a match in the dictionary, you should add it to your output line. Example output line for the correction / suggestion is like that: 


SUGGESTIONs for wird: bird gird ward word wild wind wire wiry 

<h1>Important Notes: </h1>

1) In your implementation, put the following messages at the appropriate lines: 
cout<<"INSERT: The word '"<<s<<"' is put in the cell number "<<index<<endl; 

cout<<"WARNING: The word '"<<s<<"' is already in the dictionary!"<<endl; 

cout<<"WARNING: There are no empty space in the hash table for the word: "<<s<<endl; 

cout<<"RETRIEVE: The word '"<<s<<"' found in the dictionary with index: "<<index<<endl; 

cout<<"REMOVE: The word '"<<s<<"' is removed from the dictionary."<<endl; 

cout<<"WARNING: The word '"<<s<<"' couldn't be found in the dictionary"<<endl; 
 
  
